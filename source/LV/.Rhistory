fitBenaim(4,K,p,p_k,p_kk)
out <- c(a,b,c,mu)
benaim.fit <- function(mu, K, p, p_k, p_kk, type='call'){
if(type=='put'){k=1/K}
# Solve Hx = g, for x = [b,c]'
# 2nd equation terms
h1 = c(1/(K^2), 2/(K^3))
g1 = -p_k/p - mu/K
# 3rd equation terms
h2 = c(-p_k/(K^2) + p/(K^3), 6*p/(K^4) - 2*p_k/(K^3))
g2 = p_k*mu/K - mu/(K^2) - p_kk
# write the system in matrix form
H = rbind(h1, h2)
g = matrix(c(g1,g2))
# solve
sol = solve(H)%*%g
c = sol[2]
b = sol[1]
a = log(p*K^mu) - b/K - c/(K^2)
out <- c(a,b,c,mu)
return(out)
}
benaim.predict <- function(K, par){
a <- par[1]
b <- par[2]
c <- par[3]
mu <- par[4]
return(K^-mu * exp(a+ b/K + c/K^2))
}
K=160
S=100
p=5
p_k=.5
p_kk=0.02
fit <- fitBenaim(4,K,p,p_k,p_kk)
fit
fit
flateningEtrapol <- function(x, grid, internal, method='exponential', lambda=NULL){
#
#
# DETAILS:
# * Method 'exponential' uses a convex-decreasing first-order derivative, the lambda
#   parameter controls the spead at which delta converges to zero. The higher the
#   lambda the faster is the convergence, a value of 4.6 will produce adelta at the end
#   of the new grid equal to 1% of the boundry delta from the initial grid. lambda=0
#   produces a constant delta.
# * Method 'power' uses a monotone-decreasing first-order derivative, going from the
#   the boundry delta of  the initial grid to zero. The lambda parameter controls
#   the curvature:
#   * lambda > 1 ->  concave
#   * lambda = 1 -> linear
#   * lambda > 1 -> convex
# dim
N = length(grid)
n = sum(internal)
# checks
if(n!=ncol(x)){stop('wrong dimension')}
if(!all(order(grid)==(1:N))){stop('wrong order')}
# set lambda if null
if(is.null(lambda)){
if(method=='exponential'){lambda=0} # constant
if(method=='power'){lambda=1} # linearly decreasing
}
# output matrix
x.out <- matrix(NA,nrow(x),N)
# indexing
external.low <- grid[internal][1]>grid
external.upp <- grid[internal][n]<grid
# compute 1st order derivatives
D1 <- diffMat(grid[internal])$mat
deltas <- D1%*%t(x)
delta.l <- deltas[1,]
delta.u <- deltas[n,]
# extrap. points dim
nu <- sum(external.upp)
nl <- sum(external.low)
u.bound <- nl + n
l.bound <- nl + 1
# dx
dx.u <- grid[external.upp] - c(grid[u.bound],grid[external.upp][-nu])
cum_dx.u <- grid[external.upp] - grid[u.bound]
dx.l <- c(grid[l.bound],grid[external.low][nl:2]) - grid[external.low][nl:1]
cum_dx.l <- grid[l.bound]  - grid[external.low][nl:1]
if(method=='exponential'){
#method 1
discount.l <- 1/exp((1:nl)/nl*lambda)
discount.u <- 1/exp((1:nu)/nu*lambda)
} else if(method=='power'){
# method 2
discount.l <- (1-((1:nl)/nl)^lambda)
discount.u <- (1-((1:nu)/nu)^lambda)
} else{stop('unknown method')}
# lower extrapolation
deltas <- matrix(delta.l)%*%discount.l
Ddx <- t(apply((t(deltas)*dx.l),2,cumsum))
x.out[,external.low] <- x[,1] - Ddx[,nl:1]
# upper extrapolation
deltas <- matrix(delta.u)%*%discount.u
Ddx <- t(apply((t(deltas)*dx.u),2,cumsum))
x.out[,external.upp] <- x[,n] + Ddx
# add internal points
x.out[,internal] <- x
return(x.out)
}
benaim.fit <- function(mu, K, p, p_k, p_kk, type='call'){
if(type=='put'){k=1/K}
# Solve Hx = g, for x = [b,c]'
# 2nd equation terms
h1 = c(1/(K^2), 2/(K^3))
g1 = -p_k/p - mu/K
# 3rd equation terms
h2 = c(-p_k/(K^2) + p/(K^3), 6*p/(K^4) - 2*p_k/(K^3))
g2 = p_k*mu/K - mu/(K^2) - p_kk
# write the system in matrix form
H = rbind(h1, h2)
g = matrix(c(g1,g2))
# solve
sol = solve(H)%*%g
c = sol[2]
b = sol[1]
a = log(p*K^mu) - b/K - c/(K^2)
return(c(a,b,c,mu))
}
benaim.predict <- function(K, par){
a <- par[1]
b <- par[2]
c <- par[3]
mu <- par[4]
return(K^-mu * exp(a+ b/K + c/K^2))
}
fit <- benaim.fit(4,K,p,p_k,p_kk)
fit
benaim.predict(160,fit)
fit <- benaim.fit(50,K,p,p_k,p_kk)
benaim.predict(160,fit)
fit <- benaim.fit(0,K,p,p_k,p_kk)
benaim.predict(160,fit)
K=160
S=100
p=5
p_k=.5
p_kk=0.02
fit <- benaim.fit(10,K,p,p_k,p_kk)
benaim.predict(160,fit)
fit
benaim.predict(160,fit)
fit <- benaim.fit(10,K,p,p_k,p_kk)
benaim.predict(160,fit)
K=160
K=140
S=100
p=5
K=140     # strike
S=100     # spot
p=0.22       # call price
p_k=0.035   # delta
p_kk=0.005 # gamma
fit <- benaim.fit(10,K,p,p_k,p_kk)
tail <- seq(140,100,10)
tail <- seq(140,100,length.out=10)
benaim.predict(tail, fit)
tail <- seq(140,100,length.out=10)
benaim.predict(tail, fit)
tail
tail <- seq(140,100,length.out=10)
tail
benaim.predict(tail, fit)
tail <- seq(140,1000,length.out=10)
benaim.predict(tail, fit)
tail <- seq(140,130,length.out=10)
benaim.predict(tail, fit)
tail <- seq(140,160,length.out=10)
benaim.predict(tail, fit)
tail.p <- benaim.predict(tail, fit)
plot(tail.p)
plot(tail.p)
tail.p[1]==p
tail.p <- benaim.predict(tail, fit)
tail.p
tail.p[1]
p
tail.p[1]==p
tail.p[1]>p
tail.p[1]
tail.p[1]-p
all.equal(tail.p[1],p)
all.equal
?all.equal
all.equal(tail.p[1],p, tolerance=1e-12)
all.equal(tail.p[1], p, tolerance=1e-12)
source("./source/numericalMethods/fdm.R") # for diffMat
source("./source/numericalMethods/fdm.R") # for diffMat
source("./source/numericalMethods/fdm.R") # for diffMat
source("./source/numericalMethods/fdm.R") # for diffMat
###  extrapolation.R  ###
source("./source/numericalMethods/fdm.R") # for diffMat
flateningEtrapol <- function(x, grid, internal, method='exponential', lambda=NULL){
#
#
# DETAILS:
# * Method 'exponential' uses a convex-decreasing first-order derivative, the lambda
#   parameter controls the spead at which delta converges to zero. The higher the
#   lambda the faster is the convergence, a value of 4.6 will produce adelta at the end
#   of the new grid equal to 1% of the boundry delta from the initial grid. lambda=0
#   produces a constant delta.
# * Method 'power' uses a monotone-decreasing first-order derivative, going from the
#   the boundry delta of  the initial grid to zero. The lambda parameter controls
#   the curvature:
#   * lambda > 1 ->  concave
#   * lambda = 1 -> linear
#   * lambda > 1 -> convex
# dim
N = length(grid)
n = sum(internal)
# checks
if(n!=ncol(x)){stop('wrong dimension')}
if(!all(order(grid)==(1:N))){stop('wrong order')}
# set lambda if null
if(is.null(lambda)){
if(method=='exponential'){lambda=0} # constant
if(method=='power'){lambda=1} # linearly decreasing
}
# output matrix
x.out <- matrix(NA,nrow(x),N)
# indexing
external.low <- grid[internal][1]>grid
external.upp <- grid[internal][n]<grid
# compute 1st order derivatives
D1 <- diffMat(grid[internal])$mat
deltas <- D1%*%t(x)
delta.l <- deltas[1,]
delta.u <- deltas[n,]
# extrap. points dim
nu <- sum(external.upp)
nl <- sum(external.low)
u.bound <- nl + n
l.bound <- nl + 1
# dx
dx.u <- grid[external.upp] - c(grid[u.bound],grid[external.upp][-nu])
cum_dx.u <- grid[external.upp] - grid[u.bound]
dx.l <- c(grid[l.bound],grid[external.low][nl:2]) - grid[external.low][nl:1]
cum_dx.l <- grid[l.bound]  - grid[external.low][nl:1]
if(method=='exponential'){
#method 1
discount.l <- 1/exp((1:nl)/nl*lambda)
discount.u <- 1/exp((1:nu)/nu*lambda)
} else if(method=='power'){
# method 2
discount.l <- (1-((1:nl)/nl)^lambda)
discount.u <- (1-((1:nu)/nu)^lambda)
} else{stop('unknown method')}
# lower extrapolation
deltas <- matrix(delta.l)%*%discount.l
Ddx <- t(apply((t(deltas)*dx.l),2,cumsum))
x.out[,external.low] <- x[,1] - Ddx[,nl:1]
# upper extrapolation
deltas <- matrix(delta.u)%*%discount.u
Ddx <- t(apply((t(deltas)*dx.u),2,cumsum))
x.out[,external.upp] <- x[,n] + Ddx
# add internal points
x.out[,internal] <- x
return(x.out)
}
benaim.fit <- function(mu, K, p, p_k, p_kk, type='call'){
if(type=='put'){k=1/K}
# Solve Hx = g, for x = [b,c]'
# 2nd equation terms
h1 = c(1/(K^2), 2/(K^3))
g1 = -p_k/p - mu/K
# 3rd equation terms
h2 = c(-p_k/(K^2) + p/(K^3), 6*p/(K^4) - 2*p_k/(K^3))
g2 = p_k*mu/K - mu/(K^2) - p_kk
# write the system in matrix form
H = rbind(h1, h2)
g = matrix(c(g1,g2))
# solve
sol = solve(H)%*%g
c = sol[2]
b = sol[1]
a = log(p*K^mu) - b/K - c/(K^2)
return(c(a,b,c,mu))
}
benaim.predict <- function(K, par){
a <- par[1]
b <- par[2]
c <- par[3]
mu <- par[4]
return(K^-mu * exp(a+ b/K + c/K^2))
}
source("./source/numericalMethods/fdm.R") # for diffMat
source("./numericalMethods/fdm.R") # for diffMat
if(!require("fields")) install.packages("fields") # for Tps
source("./source/numericalMethods/fdm.R") # for diffMat
source("./source/numericalMethods/fdm.R") # for diffMat
source("./source/BSformulas.R")
###  extrapolation.R  ###
source("./source/numericalMethods/fdm.R") # for diffMat
flateningEtrapol <- function(x, grid, internal, method='exponential', lambda=NULL){
#
#
# DETAILS:
# * Method 'exponential' uses a convex-decreasing first-order derivative, the lambda
#   parameter controls the spead at which delta converges to zero. The higher the
#   lambda the faster is the convergence, a value of 4.6 will produce adelta at the end
#   of the new grid equal to 1% of the boundry delta from the initial grid. lambda=0
#   produces a constant delta.
# * Method 'power' uses a monotone-decreasing first-order derivative, going from the
#   the boundry delta of  the initial grid to zero. The lambda parameter controls
#   the curvature:
#   * lambda > 1 ->  concave
#   * lambda = 1 -> linear
#   * lambda > 1 -> convex
# dim
N = length(grid)
n = sum(internal)
# checks
if(n!=ncol(x)){stop('wrong dimension')}
if(!all(order(grid)==(1:N))){stop('wrong order')}
# set lambda if null
if(is.null(lambda)){
if(method=='exponential'){lambda=0} # constant
if(method=='power'){lambda=1} # linearly decreasing
}
# output matrix
x.out <- matrix(NA,nrow(x),N)
# indexing
external.low <- grid[internal][1]>grid
external.upp <- grid[internal][n]<grid
# compute 1st order derivatives
D1 <- diffMat(grid[internal])$mat
deltas <- D1%*%t(x)
delta.l <- deltas[1,]
delta.u <- deltas[n,]
# extrap. points dim
nu <- sum(external.upp)
nl <- sum(external.low)
u.bound <- nl + n
l.bound <- nl + 1
# dx
dx.u <- grid[external.upp] - c(grid[u.bound],grid[external.upp][-nu])
cum_dx.u <- grid[external.upp] - grid[u.bound]
dx.l <- c(grid[l.bound],grid[external.low][nl:2]) - grid[external.low][nl:1]
cum_dx.l <- grid[l.bound]  - grid[external.low][nl:1]
if(method=='exponential'){
#method 1
discount.l <- 1/exp((1:nl)/nl*lambda)
discount.u <- 1/exp((1:nu)/nu*lambda)
} else if(method=='power'){
# method 2
discount.l <- (1-((1:nl)/nl)^lambda)
discount.u <- (1-((1:nu)/nu)^lambda)
} else{stop('unknown method')}
# lower extrapolation
deltas <- matrix(delta.l)%*%discount.l
Ddx <- t(apply((t(deltas)*dx.l),2,cumsum))
x.out[,external.low] <- x[,1] - Ddx[,nl:1]
# upper extrapolation
deltas <- matrix(delta.u)%*%discount.u
Ddx <- t(apply((t(deltas)*dx.u),2,cumsum))
x.out[,external.upp] <- x[,n] + Ddx
# add internal points
x.out[,internal] <- x
return(x.out)
}
benaim.fit <- function(mu, K, p, p_k, p_kk, type='call'){
if(type=='put'){k=1/K}
# Solve Hx = g, for x = [b,c]'
# 2nd equation terms
h1 = c(1/(K^2), 2/(K^3))
g1 = -p_k/p - mu/K
# 3rd equation terms
h2 = c(-p_k/(K^2) + p/(K^3), 6*p/(K^4) - 2*p_k/(K^3))
g2 = p_k*mu/K - mu/(K^2) - p_kk
# write the system in matrix form
H = rbind(h1, h2)
g = matrix(c(g1,g2))
# solve
sol = solve(H)%*%g
c = sol[2]
b = sol[1]
a = log(p*K^mu) - b/K - c/(K^2)
return(c(a,b,c,mu))
}
benaim.predict <- function(K, par){
a <- par[1]
b <- par[2]
c <- par[3]
mu <- par[4]
return(K^-mu * exp(a+ b/K + c/K^2))
}
K=140     # strike
S=100     # spot
p=0.22       # call price
p_k=-0.035   # delta
p_kk=0.005 # gamma
fit <- benaim.fit(5,K,p,p_k,p_kk)
tail.K <- seq(140,200,length.out=20)
tail.p <- benaim.predict(tail.K, fit)
all.equal(tail.p[length(tail.p)], 0, tolerance=1e-12)
all.equal(tail.p[1], p, tolerance=1e-12)
all(diffMat(tail.K,1)$mat%*%tail.p<=0)
source("./source/numericalMethods/fdm.R") # for diffMat
###  examples.R  ###
rm(list = ls())
source("./source/BSformulas.R")
source("./source/plotter.R")
source("./source/LV/pre_smoother.R")
source("./source/LV/Fengler09.R")
source("./source/LV/cubicSpline.R")
source("./source/LV/Dupire.R")
# load dataset
load("./Rdata/data.RData")
#
# EXAMPLE 1
# Pre-Smoothing: old vs new grid
#
#  set date
t=1
# initial expiration and forward-moneyness coordinates
tmp <- expand.grid(data[[t]]$forward, data[[t]]$strikes)
moneyness <- tmp[,2]/tmp[,1]
initialXY <- cbind.data.frame(expiry = expand.grid(data[[t]]$expiries, data[[t]]$strikes)[,1],
moneyness)
# set forward-moneyness grid
nk <- 10
k_grid <- seq(0.75, 1.2, length=nk)
add_t <- c(0.8, 0.9)
nt <- length(c(data[[t]]$expiries, add_t))
# pre-smoothe the ivs
arguments <- c(data[[t]], list(k_grid = k_grid,
add_t = add_t))
preSmooth <- do.call(TPSpreSmoother, arguments)
# extract the new (regular) grid in foward moneynes
newGrid <- preSmooth$xy
# grups for ggplot
newGrid$g1 <- rep(1:nt, nk)
newGrid$g2 <- sort(rep(1:nk, nt))
# 2D plot
library(ggplot2)
ggplot(newGrid, aes(x=expiry, y=k)) +
geom_point(alpha = 0.5) +
geom_line(aes(group = g1), linetype="dotted") +
geom_line(aes(group = g2), linetype="dotted") +
geom_point(data = initialXY, aes(x=expiry, y=moneyness), col = "red", alpha = 0.5)
# 3D IVS plot (forward moneyness)
xyz <- cbind(initialXY, iv = as.vector(data[[t]]$iv))
open3d()
points3d(xyz, size = 7) # old knots
visualizeSurface(preSmooth$t_grid , preSmooth$k_grid, preSmooth$iv) # new surface
# 3D prices plot (forward moneyness)
initial_p <- as.vector(do.call(BScall_price2D, data[[t]]))
xyz <- cbind(initialXY, price = initial_p)
open3d()
points3d(xyz, size = 7) # new knots
visualizeSurface(preSmooth$t_grid , preSmooth$k_grid, preSmooth$p) # original surface
#
# EXAMPLE 2
# quadratic program
#
# rm(list = ls())
# set parameters
t=1
k_grid_length = 50
lambda = 1e-2
add_t = c(0.79, 0.83, 0.87, 0.90, 0.93, 0.96, 0.99, 1)
# presmooth the ivs
k_grid <- seq(0.70, 1.25, length = k_grid_length)
arguments <- c(data[[t]], list(k_grid = k_grid,
add_t = add_t))
preSmooth <- do.call(TPSpreSmoother, arguments)
# solve quadratic programm
arguments2 <- c(preSmooth, list(smooth = lambda,
spot = data[[t]]$spot))
cs <-do.call(solveQuadprog, arguments2)
# compute intermediate strikes
points <- seq(min(data[[t]]$strikes)-0, max(data[[t]]$strikes)+0, length.out = 100)
val <- matrix(NA, length(preSmooth$t_grid), 100)
for (i in 1:100){
for (j in 1:length(preSmooth$t_grid)){
val[j,i] <- evalSplin(points[i], cs$K[j,], cs$p[j,], cs$gamma[j,])
}
}
# 2D
exp = 1
plot(val[exp,], x = points, type = "l") # interpolated prices
points(preSmooth$p[exp,(ncol(preSmooth$p):1)], x = cs$K[exp,], type = "p") # from smoothed greed
initial_p <- do.call(BScall_price2D, data[[t]])
points(initial_p[exp,], x = data[[t]]$strikes, type = "p", pch = 8) # from smoothed greed
# 3D
open3d()
visualizeSurface(x = preSmooth$t_grid, y = points, z = val, alpha=0.3) # interpolated points
for (i in 1:nrow(cs$p)){
lines3d(x = preSmooth$t_grid[i], y = points, z = val[i,], lwd = 3, col = "green")
}
xy <- expand.grid(data[[t]]$expiries, data[[t]]$strikes)
xyz <- cbind(xy, as.vector(initial_p))
points3d(xyz, size = 6) # original prices
## NEW GRID ##
K2 <- seq(data[[t]]$spot*0.8, data[[t]]$spot*1.2, length.out = k_grid_length)
cs2 <- c.spline_predict(K2 ,cs$K ,cs$p, cs$gamma)
# LOCAL VOL SURFACE
# to improve ?
nt <- length(preSmooth$t_grid)
c_t <- (cs2$g[2:nt,] - cs2$g[1:(nt-1),])/
(preSmooth$t_grid[2:nt]-preSmooth$t_grid[1:(nt-1)])
# Reduce grid
gamma <- cs2$gamma[1:(nt-1),]
p <- cs2$g[1:(nt-1),]
delta <- cs2$delta[1:(nt-1),]
t_grid <- preSmooth$t_grid[1:(nt-1)]
rates <- preSmooth$rates[1:(nt-1)]
dividends <- preSmooth$dividends[1:(nt-1)]
